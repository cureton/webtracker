<script>
  let port, writer, satrec, intervalId, chart, map, footprintMap;
  let satMarker, trailLine, observerMarker, footprintCircle, subpointMarker;
  let aosMarker, losMarker, predictionLine, footprintTrailLine;
  let lastElevation = null;
  const trailCoords = [];
  const footprintTrailCoords = [];

  function setupTrackingLoop() {
    clearInterval(intervalId);
    intervalId = setInterval(() => {
      const now = new Date();
      const gmst = satellite.gstime(now);
      const posVel = satellite.propagate(satrec, now);
      if (!posVel.position) return;

      const geo = satellite.eciToGeodetic(posVel.position, gmst);
      const lat = satellite.degreesLat(geo.latitude);
      const lon = satellite.degreesLong(geo.longitude);

      // Ground track for main map
      trailCoords.push([lat, lon]);
      if (trailCoords.length > 200) trailCoords.shift();
      if (trailLine) map.removeLayer(trailLine);
      trailLine = L.polyline(trailCoords, { color: 'blue' }).addTo(map);

      // Ground track for footprint map
      footprintTrailCoords.push([lat, lon]);
      if (footprintTrailCoords.length > 200) footprintTrailCoords.shift();
      if (footprintTrailLine) footprintMap.removeLayer(footprintTrailLine);
      footprintTrailLine = L.polyline(footprintTrailCoords, { color: 'blue' }).addTo(footprintMap);

      // Draw satellite footprint
      const altitude = geo.height;
      const earthRadius = 6371; // km
      const minElevationRad = 0;
      const angularRadius = Math.acos((earthRadius / (earthRadius + altitude)) * Math.cos(minElevationRad));
      const footprintRadiusKm = earthRadius * angularRadius;

      if (!subpointMarker) {
        subpointMarker = L.circleMarker([lat, lon], { radius: 4, color: 'purple', fillColor: 'violet', fillOpacity: 0.9 }).addTo(footprintMap);
      } else {
        subpointMarker.setLatLng([lat, lon]);
      }

      if (footprintCircle) {
        footprintCircle.setLatLng([lat, lon]);
        footprintCircle.setRadius(footprintRadiusKm * 1000);
      } else {
        footprintCircle = L.circle([lat, lon], {
          radius: footprintRadiusKm * 1000,
          color: 'purple', fillColor: 'purple', fillOpacity: 0.2
        }).addTo(footprintMap);
      }

      // Calculate azimuth and elevation from observer
      const lookAngles = satellite.ecfToLookAngles(
        observerGd,
        satellite.eciToEcf(posVel.position, gmst)
      );
      const az = satellite.radiansToDegrees(lookAngles.azimuth);
      const el = satellite.radiansToDegrees(lookAngles.elevation);

      // Send command to AlphaSpid rotator
      const azCmd = Math.round(az * 10).toString().padStart(4, '0');
      const elCmd = Math.round(el * 10).toString().padStart(3, '0');
      const command = `W${azCmd}${elCmd}\r`;
      if (writer) writer.write(command);

      // AOS/LOS detection
      const justAOS = lastElevation !== null && lastElevation <= 0 && el > 0;
      const justLOS = lastElevation !== null && lastElevation > 0 && el <= 0;
      lastElevation = el;

      if (justAOS) {
        if (aosMarker) map.removeLayer(aosMarker);
        aosMarker = L.marker([lat, lon], {
          icon: L.divIcon({ className: 'aos-icon', html: 'AOS', iconAnchor: [0, 0] })
        }).addTo(map);
        log(`AOS at ${lat.toFixed(2)}, ${lon.toFixed(2)} at ${now.toLocaleTimeString()}`);
      }

      if (justLOS) {
        if (losMarker) map.removeLayer(losMarker);
        losMarker = L.marker([lat, lon], {
          icon: L.divIcon({ className: 'los-icon', html: 'LOS', iconAnchor: [0, 0] })
        }).addTo(map);
        log(`LOS at ${lat.toFixed(2)}, ${lon.toFixed(2)} at ${now.toLocaleTimeString()}`);
      }

      // Update Az/El plot
      if (el > 0) {
        chart.data.datasets[0].data.push({ x: az, y: el });
        chart.update();
      }
    }, 1000);
  }
</script>
